---
type: update
version: 1.6.1
id: auto-cluster-addon
name: Auto-Clustering
logo: https://github.com/jelastic-jps/glassfish/raw/master/glassfish-cluster/img/glassfish-logo.png
description: 'Auto-clustering: transforming standalone nodes to cluster'

globals:
  port: 28080
  payara: false
  path: /home/jelastic/.ssh
  
nodeGroupAlias:
  ${targetNodes.nodeGroup}: cp
    
onInstall:
  - if ('${nodes.cp.master.nodeType}'.indexOf('payara') > -1):
      setGlobals:
        payara: true

  - if (nodes.das): 
    - if (${settings.clone:false}):
      - cleanCluster
      - if (${globals.payara}):
          addHost2Hazelcast: ${nodes.cp.join(id,)}
      - exposePort: ${nodes.cp.join(id,)}
      - restartContainers[${nodes.cp.join(id,)}]
      - restartRequired      
    - else: 
        buildCluster:
          redeploy: false        
  - else:
      buildCluster:
        redeploy: false        
        
onBeforeServiceScaleOut[cp]:
  - if (nodes.das):
      - uploadEncFiles: 
          ids: ${event.response.nodes.join(id,)}
      - if (${globals.payara}):
          addHost2Hazelcast: ${event.response.nodes.join(id,)}
      - exposePort: ${event.response.nodes.join(id,)}
        
  - elif (nodes.cp.length > 1):
      buildCluster:
        redeploy: true
      
onBeforeScaleIn[cp]:
  - if (${globals.payara}):
      removeHostFromHazelcast: ${event.response.nodes.join(id,)}
  - cmd[${event.response.nodes.join(id,)}]: $STACK_PATH/service.sh delete
  
onAfterScaleOut[cp]:
  if (nodes.das): restartRequired
onAfterScaleIn[cp]:
  if (nodes.das): restartRequired

onAfterClone:
  - script: delete MANIFEST.id; return {result:0, jps:MANIFEST};
  - install[${targetNodes.nodeGroup}]: ${response.jps}
    envName: ${event.response.env.envName}    
    settings: 
      clone: true    
    
onBeforeSetCloudletCount[cp]:
  if (nodes.das):
    cmd[${nodes.cp.master.id}]: touch $STACK_PATH/.skiprestart
    
onAfterSetCloudletCount[cp]:
  if (nodes.das):
    cmd[das]: $STACK_PATH/service.sh restartAllInstances
    
onAfterSetCloudletCount[das]:
  cmd[das]: $STACK_PATH/service.sh restart
        
onAfterMigrate:
  - cmd[cp]: |-
      $STACK_PATH/service.sh addRedirect2Das "node${nodes.das.master.id}-${env.domain}:4848"

onAfterResetNodePassword:
  uploadEncFiles: 
    ids: ${nodes.cp.join(id,)}
    mode: pswd
  
onAfterBindSSL:
  - if (nodes.cp.length == 1):
    - log: after bind SSL
    - cmd[${nodes.das.master.id}]: |-
        mkdir -p /var/lib/jelastic/SSL/
        chown $STACK_USER:$STACK_USER -R /var/lib/jelastic/SSL/
      user: root
    - environment.file.write:
        nodeid: ${nodes.das.master.id}
        path: /var/lib/jelastic/SSL/customssl.conf
        user: root
        body: |
          key=${event.params.cert_key}
          intermediate=${event.params.intermediate}
          cert=${event.params.cert}
    - cmd[${nodes.das.master.id}]: jem ssl install
      user: root

onAfterRemoveSSL:
  - if (nodes.cp.length == 1):
    - cmd[${nodes.das.master.id}]:
      - jem ssl remove
      user: root
  
actions:
  cleanCluster:
    cmd[${nodes.das.master.id}]: $STACK_PATH/service.sh clean
    
  buildCluster:
    #for 5.8.1+ [---
    - if (nodes.das): 
        env.control.AddContainerEnvVars[${nodes.das.master.id}]:
          vars: {"DAS":"true", "PASS":"${fn.password}"}
    # ---]
    - else: 
      #for < 5.8.1 [---
      - addNodes:
          fixedCloudlets: ${nodes.cp.master.fixedCloudlets}
          flexibleCloudlets: ${nodes.cp.master.flexibleCloudlets}
          displayName: DAS
          nodeType: ${nodes.cp.master.nodeType}
          tag: ${nodes.cp.master.version}
          nodeGroup: das
          metadata:
            layer: das
          dockerEnvVars:
            DAS: 'true'
          startService: false
          nodeGroupData:
            validation:
                maxCount: 1
                scalingMode: STATEFUL
            isClusterSupport: false
            isDeploySupport: false

      - api: env.control.SetNodeGroupDisplayName
        nodeGroup: das
        displayName: DAS
    # ---]
    
    - api: env.control.SetNodeGroupDisplayName
      nodeGroup: cp
      displayName: Workers

    - configureLinksAndKeys:
        redeploy: ${this.redeploy}
      
  restartRequired:
    cmd[das]: $STACK_PATH/service.sh restartRequired
  
  redeployApps:
    cmd[${nodes.cp.master.id}]: $STACK_PATH/service.sh redeploy
    
  copyConfigsAndApps:
    - cmd[${nodes.cp.master.id}]: $STACK_PATH/service.sh copyConfigsAndApps
      
  exposePort:
    cmd[${this}]: $STACK_PATH/service.sh exposePort ${globals.port}
    user: root
    
  addHost2Hazelcast:
    editHazelcast:
      ids: ${this}
      act: add
  removeHostFromHazelcast:
    editHazelcast:
      ids: ${this}
      act: remove
  editHazelcast:
    - script: |
        var ids = "${this.ids}".split(","), cmd = [];
        for (var i = 0; i < ids.length; i++) cmd.push("$STACK_PATH/service.sh ${this.act}Host node" + ids[i]); 
        return {result: 0, onAfterReturn: {'cmd[das]': cmd.join("; ")}}
      
  generateSSHKeys: 
    cmd[${nodes.das.master.id}]: $STACK_PATH/service.sh generateKeys
    
  uploadEncFiles:          
    - cmd[${nodes.das.master.id}]: $STACK_PATH/service.sh getEncFiles ${this.mode:}
    - script: |
        var f = out.split('///'), action = {}; 
        action['cmd[' + ids + ']'] = ("$STACK_PATH/service.sh setEncFiles '" + f[0] + (f.length > 1 ? ("' '" + f[1] + "' '" + f[2] + "' '" + f[3])  : "") + "'").replace(/\n/g, "\\n");
        return {result:0, onAfterReturn:action}
      out: ${response.out}
      ids: ${this.ids}

  configureLinksAndKeys:  
    - linkContainers:
        ids: ${nodes.cp.join(id,)}
    - cmd[${nodes.cp.master.id}]: mv $PSWD_FILE ${PSWD_FILE}.old
    - generateSSHKeys
    - uploadEncFiles: 
        ids: ${nodes.cp.join(id,)}
    - if (${globals.payara}):
        addHost2Hazelcast: ${nodes.cp.join(id,)}
    - exposePort: ${nodes.cp.join(id,)}
    - if (${this.redeploy}): copyConfigsAndApps
    - api: env.control.ExecDockerRunCmd
      nodeId: ${nodes.das.master.id}
    - if (${this.redeploy}): redeployApps  
    - restartContainers[${nodes.cp.join(id,)}]
    - restartRequired
    
  linkContainers:     
    script: |
      var ids = "${this.ids}".split(","), api = [];        
      for (var i = 0; i < ids.length; i++) 
        api.push({
          method: "env.control.LinkDockerNodes", 
          params: {
            sourceNodeId: ${nodes.das.master.id}, 
            targetNodeId: ids[i], 
            alias: "das", 
            groupAlias: "das"
          }
        }); 
      return {result: 0, onAfterReturn: {api:api}}
